import dotenv from 'dotenv';
dotenv.config();

import express from 'express';
import cors from 'cors';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createClient } from '@sanity/client';
import { v4 as uuidv4 } from 'uuid';

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// --- Configura√ß√£o da Gemini API ---
// Garante que a chave da API est√° presente
if (!process.env.GEMINI_API_KEY) {
    console.error("Erro: Vari√°vel de ambiente GEMINI_API_KEY n√£o definida.");
    process.exit(1);
}
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// --- Configura√ß√£o do Sanity Client para o Backend ---
// Garante que as credenciais do Sanity est√£o presentes
if (!process.env.SANITY_PROJECT_ID || !process.env.SANITY_TOKEN) {
    console.error("Erro: Vari√°veis de ambiente SANITY_PROJECT_ID ou SANITY_TOKEN n√£o definidas.");
    process.exit(1);
}
const sanityClient = createClient({
    projectId: process.env.SANITY_PROJECT_ID,
    dataset: process.env.SANITY_DATASET || 'production',
    apiVersion: '2024-06-25', // Usando a data de hoje, uma vers√£o est√°vel mais recente
    useCdn: false,
    token: process.env.SANITY_TOKEN, // Usar√° o token de escrita do .env
});

// --- Rotas da API ---
app.get('/', (req, res) => {
    res.send('Servidor do backend "Meus Cursos" est√° rodando! üôå');
});

// Helper para converter string de texto para Portable Text b√°sico (apenas blocos de par√°grafo)
const convertToPortableText = (text) => {
    if (!text) return [];
    const paragraphs = text.split('\n\n').filter(p => p.trim() !== '');

    return paragraphs.map(p => ({
        _key: uuidv4(),
        _type: 'block',
        children: [
            {
                _key: uuidv4(),
                _type: 'span',
                marks: [],
                text: p.trim(),
            },
        ],
        markDefs: [],
        style: 'normal',
    }));
};

app.post('/api/courses/generate', async (req, res) => {
    const { topic } = req.body;

    if (!topic) {
        return res.status(400).json({ error: 'Um t√≥pico √© necess√°rio para gerar o curso.' });
    }

    try {
        const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" }); 

        const prompt = `Gere um esquema de curso detalhado em portugu√™s sobre "${topic}".
        O esquema deve conter:
        - Um campo 'title' (string): T√≠tulo do curso.
        - Um campo 'description' (string): Uma breve descri√ß√£o do curso (1-2 frases).
        - Um campo 'slug' (string): Um slug √∫nico e formatado para URL (ex: "introducao-a-ia").
        - Um campo 'lessons' (array de objetos): Uma lista de 5 a 7 li√ß√µes. Cada li√ß√£o deve ter:
          - 'title' (string): T√≠tulo da li√ß√£o.
          - 'slug' (string): Slug √∫nico da li√ß√£o.
          - 'order' (number): A ordem da li√ß√£o no curso, come√ßando de 1.
          - 'content' (string): Conte√∫do detalhado da li√ß√£o (3-5 par√°grafos de texto corrido, sem formata√ß√£o Markdown complexa ou HTML).
          - 'estimatedReadingTime' (number): Tempo estimado de leitura em minutos para esta li√ß√£o (entre 3 e 15).
        A resposta deve ser APENAS um objeto JSON v√°lido, sem nenhum texto introdut√≥rio ou explicativo, e sem aspas triplas ('''json) ou outros caracteres extras.
        Exemplo de formato JSON para as li√ß√µes:
        "lessons": [
          {
            "title": "Titulo da Licao 1",
            "slug": "titulo-da-licao-1",
            "order": 1,
            "content": "Conte√∫do do par√°grafo 1.\\n\\nConte√∫do do par√°grafo 2.",
            "estimatedReadingTime": 7
          }
        ]`;

        console.log(`Gerando curso para o t√≥pico: "${topic}"...`);
        const geminiResponse = await model.generateContent(prompt);
        const text = geminiResponse.response.candidates[0].content.parts[0].text;

        let generatedCourseData;
        try {
            let cleanText = text.replace(/```json\n|```json|```/g, '').trim();
            // Nova linha de corre√ß√£o para caracteres de controle
            cleanText = cleanText.replace(/[\u0000-\u001F\u007F-\u009F\u00A0]/g, '').replace(/(\r\n|\n|\r)/gm, '\\n');
            
            generatedCourseData = JSON.parse(cleanText);
        } catch (parseError) {
            console.error("Erro ao parsear JSON da Gemini API:", parseError);
            console.error("Texto bruto recebido da Gemini:", text);
            return res.status(500).json({ error: 'Erro ao processar a resposta da IA. Formato JSON inv√°lido.', rawText: text });
        }

        // ATEN√á√ÉO: Este ID PRECISA ser o _id de um documento 'member' existente no seu Sanity Studio.
        const dummyCreatorId = '43893a06-75ab-4313-a81b-9947524fdbeb'; 

        const courseId = `course-${uuidv4()}`;

        const transaction = sanityClient.transaction();

        const lessonRefs = [];
        for (const lesson of generatedCourseData.lessons) {
            const lessonSlug = { current: lesson.slug || `${generatedCourseData.slug}-${lesson.order}` };
            const lessonId = `lesson-${uuidv4()}`;

            const newLesson = {
                _id: lessonId,
                _type: 'lesson',
                title: lesson.title,
                slug: lessonSlug,
                content: convertToPortableText(lesson.content),
                order: lesson.order,
                estimatedReadingTime: lesson.estimatedReadingTime || 5,
                status: 'published',
                course: {
                    _ref: courseId,
                    _type: 'reference',
                    _weak: true,
                },
            };

            transaction.create(newLesson);
            lessonRefs.push({
                _key: uuidv4(),
                _ref: lessonId,
                _type: 'reference'
            });
            console.log(`Li√ß√£o "${lesson.title}" adicionada √† transa√ß√£o.`);
        }

        const newCourse = {
            _id: courseId,
            _type: 'course',
            title: generatedCourseData.title,
            description: generatedCourseData.description,
            slug: { current: generatedCourseData.slug },
            lessons: lessonRefs,
            status: 'published',
            price: 0,
            isProContent: false,
            level: 'beginner',
            estimatedDuration: `${generatedCourseData.lessons.length * 10} minutos`,
            creator: {
                _ref: dummyCreatorId,
                _type: 'reference',
                _weak: true,
            },
            // Se 'category' e 'subCategory' s√£o obrigat√≥rios no seu schema do Sanity,
            // voc√™ precisar√° adicionar IDs v√°lidos aqui. Exemplo:
            // category: { _ref: 'seu_id_da_categoria', _type: 'reference' },
            // subCategory: { _ref: 'seu_id_da_subcategoria', _type: 'reference' },
            aiGenerationPrompt: prompt,
            aiModelUsed: model.model,
            generatedAt: new Date().toISOString(),
            lastGenerationRevision: new Date().toISOString(),
        };

        transaction.create(newCourse);
        console.log(`Curso "${newCourse.title}" adicionado √† transa√ß√£o.`);

        const sanityResult = await transaction.commit();
        console.log(`Transa√ß√£o conclu√≠da.`); // Log simplificado aqui

        if (Array.isArray(sanityResult)) { // <-- VERIFICA√á√ÉO ADICIONADA AQUI
            console.log(`IDs dos documentos criados:`, sanityResult.map(doc => doc._id));
            res.status(201).json({
                message: 'Curso e li√ß√µes gerados e salvos com sucesso!',
                course: sanityResult[0],
                lessons: generatedCourseData.lessons
            });
        } else {
            console.warn("A transa√ß√£o com o Sanity n√£o retornou um array de resultados. Verifique o log do backend para mais detalhes.");
            res.status(201).json({
                message: 'Curso e li√ß√µes gerados e salvos com sucesso! (Verifique o log do backend para detalhes)',
                course: null,
                lessons: generatedCourseData.lessons
            });
        }

    } catch (error) {
        console.error("Erro no processo de gera√ß√£o/salvamento do curso:", error);
        // Erros da API Gemini
        if (error.response && error.response.data && error.response.data.error) {
            console.error("Erro da Gemini API:", error.response.data.error);
            return res.status(500).json({ error: `Erro da Gemini API: ${error.response.data.error.message}`, details: error.response.data });
        }
        // Erros do Sanity
        if (error.statusCode) {
            console.error("Erro do Sanity:", error.message);
            return res.status(500).json({ error: `Erro do Sanity CMS: ${error.message}`, details: error });
        }
        // Outros erros
        res.status(500).json({ error: 'Falha interna ao gerar ou salvar o curso.', details: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`üöÄ Servidor do backend rodando em http://localhost:${PORT}`);
    console.log('Aguardando requisi√ß√µes do frontend...');
    console.log('Endpoints dispon√≠veis:');
    console.log(`    GET /`);
    console.log(`    POST /api/courses/generate`);
});