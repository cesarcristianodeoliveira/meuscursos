import dotenv from 'dotenv';
dotenv.config();

import express from 'express';
import cors from 'cors';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { createClient } from '@sanity/client';
import { v4 as uuidv4 } from 'uuid';
import jwt from 'jsonwebtoken'; // Importar jsonwebtoken para o middleware de prote√ß√£o

// Importa as fun√ß√µes de registro e login do controlador de autentica√ß√£o
import { register, login } from './controllers/authController.js'; 

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors()); // Habilita CORS para permitir requisi√ß√µes de origens diferentes
app.use(express.json()); // Habilita o parsing de JSON no corpo das requisi√ß√µes

// --- Configura√ß√£o da Gemini API ---
if (!process.env.GEMINI_API_KEY) {
    console.error("Erro: Vari√°vel de ambiente GEMINI_API_KEY n√£o definida.");
    process.exit(1); // Encerra o processo se a chave n√£o estiver configurada
}
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// --- Configura√ß√£o do Sanity Client para o Backend ---
// Assegura que as vari√°veis de ambiente necess√°rias est√£o definidas
if (!process.env.SANITY_PROJECT_ID || !process.env.SANITY_TOKEN) {
    console.error("Erro: Vari√°veis de ambiente SANITY_PROJECT_ID ou SANITY_TOKEN n√£o definidas.");
    process.exit(1); // Encerra o processo se as chaves do Sanity n√£o estiverem configuradas
}
const sanityClient = createClient({
    projectId: process.env.SANITY_PROJECT_ID,
    dataset: process.env.SANITY_DATASET || 'production', // 'production' √© o padr√£o se n√£o especificado
    apiVersion: '2024-06-25', // Use a data atual ou a vers√£o da sua API Sanity
    useCdn: false, // Backend deve sempre acessar a API diretamente, n√£o o CDN
    token: process.env.SANITY_TOKEN, // Token com permiss√µes de escrita (cria√ß√£o de documentos)
});

// --- Middleware de Autentica√ß√£o (JWT Protection) ---
// Esta fun√ß√£o ser√° usada em rotas que requerem que o usu√°rio esteja logado
const protect = (req, res, next) => {
    let token;

    // 1. Verifica se o token est√° presente no cabe√ßalho 'Authorization'
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            // Extrai o token do formato "Bearer TOKEN"
            token = req.headers.authorization.split(' ')[1];

            // 2. Verifica e decodifica o token usando a chave secreta
            const decoded = jwt.verify(token, process.env.JWT_SECRET);

            // 3. Anexa as informa√ß√µes do usu√°rio (id, isAdmin, plan) √† requisi√ß√£o
            // Isso permite que as rotas protegidas saibam quem fez a requisi√ß√£o
            // N√£o buscamos o usu√°rio do Sanity aqui por performance; as infos do token s√£o suficientes.
            req.user = { 
                id: decoded.id, 
                isAdmin: decoded.isAdmin, 
                plan: decoded.plan 
            }; 
            next(); // Prossegue para a pr√≥xima fun√ß√£o middleware ou para a rota final

        } catch (error) {
            console.error('Erro na autentica√ß√£o do token:', error);
            // Retorna 401 se o token for inv√°lido ou expirado
            return res.status(401).json({ message: 'N√£o autorizado, token inv√°lido ou expirado.' });
        }
    }

    // Retorna 401 se nenhum token for fornecido
    if (!token) {
        return res.status(401).json({ message: 'N√£o autorizado, nenhum token fornecido.' });
    }
};

// --- Helper para converter string de texto para Portable Text b√°sico ---
// Usado para o campo 'content' das li√ß√µes no Sanity
const convertToPortableText = (text) => {
    if (!text) return [];
    // Divide o texto em par√°grafos usando quebras de linha duplas
    const paragraphs = text.split('\n\n').filter(p => p.trim() !== '');

    return paragraphs.map(p => ({
        _key: uuidv4(), // ID √∫nico para cada bloco Portable Text
        _type: 'block', // Tipo de bloco Portable Text (sempre 'block' para par√°grafos)
        children: [
            {
                _key: uuidv4(),
                _type: 'span', // Tipo de conte√∫do dentro do bloco
                marks: [], // Formata√ß√£o de texto (negrito, it√°lico, etc. - vazia para texto corrido)
                text: p.trim(), // O texto do par√°grafo
            },
        ],
        markDefs: [], // Defini√ß√µes para marcas (links, etc. - vazia aqui)
        style: 'normal', // Estilo do par√°grafo (padr√£o)
    }));
};

// --- Rotas da API ---

// Rota de teste simples para verificar se o servidor est√° rodando
app.get('/', (req, res) => {
    res.send('Servidor do backend "Meus Cursos" est√° rodando! üôå');
});

// Rotas de Autentica√ß√£o (N√ÉO protegidas, pois s√£o para login/registro)
app.post('/api/auth/register', register); // Rota para criar um novo usu√°rio
app.post('/api/auth/login', login);      // Rota para logar um usu√°rio existente

// Rota de Gera√ß√£o de Cursos (AGORA PROTEGIDA)
// O middleware 'protect' √© executado antes da l√≥gica da rota.
// Se o token for inv√°lido, a requisi√ß√£o √© rejeitada aqui.
app.post('/api/courses/generate', protect, async (req, res) => { 
    // req.user agora cont√©m { id: ..., isAdmin: ..., plan: ... } do usu√°rio logado
    const { topic } = req.body;

    if (!topic) {
        return res.status(400).json({ error: 'Um t√≥pico √© necess√°rio para gerar o curso.' });
    }

    try {
        const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" }); 

        const prompt = `Gere um esquema de curso detalhado em portugu√™s sobre "${topic}".
        O esquema deve conter:
        - Um campo 'title' (string): T√≠tulo do curso.
        - Um campo 'description' (string): Uma breve descri√ß√£o do curso (1-2 frases).
        - Um campo 'slug' (string): Um slug √∫nico e formatado para URL (ex: "introducao-a-ia").
        - Um campo 'lessons' (array de objetos): Uma lista de 5 a 7 li√ß√µes. Cada li√ß√£o deve ter:
            - 'title' (string): T√≠tulo da li√ß√£o.
            - 'slug' (string): Slug √∫nico da li√ß√£o.
            - 'order' (number): A ordem da li√ß√£o no curso, come√ßando de 1.
            - 'content' (string): Conte√∫do detalhado da li√ß√£o (3-5 par√°grafos de texto corrido, sem formata√ß√£o Markdown complexa ou HTML).
            - 'estimatedReadingTime' (number): Tempo estimado de leitura em minutos para esta li√ß√£o (entre 3 e 15).
        A resposta deve ser APENAS um objeto JSON v√°lido, sem nenhum texto introdut√≥rio ou explicativo, e sem aspas triplas ('''json) ou outros caracteres extras.
        Exemplo de formato JSON para as li√ß√µes:
        "lessons": [
            {
                "title": "Titulo da Licao 1",
                "slug": "titulo-da-licao-1",
                "order": 1,
                "content": "Conte√∫do do par√°grafo 1.\\n\\nConte√∫do do par√°grafo 2.",
                "estimatedReadingTime": 7
            }
        ]`;

        console.log(`Gerando curso para o t√≥pico: "${topic}" para o usu√°rio ${req.user.id}...`);
        const geminiResponse = await model.generateContent(prompt);
        const text = geminiResponse.response.candidates[0].content.parts[0].text;

        let generatedCourseData;
        try {
            let cleanText = text.replace(/```json\n|```json|```/g, '').trim();
            // Remove caracteres de controle (Unicode) e substitui quebras de linha para JSON v√°lido
            cleanText = cleanText.replace(/[\u0000-\u001F\u007F-\u009F\u00A0]/g, '').replace(/(\r\n|\n|\r)/gm, '\\n');
            
            generatedCourseData = JSON.parse(cleanText);
        } catch (parseError) {
            console.error("Erro ao parsear JSON da Gemini API:", parseError);
            console.error("Texto bruto recebido da Gemini:", text);
            return res.status(500).json({ error: 'Erro ao processar a resposta da IA. Formato JSON inv√°lido.', rawText: text });
        }

        // Usa o ID do usu√°rio autenticado como o criador do curso
        const creatorId = req.user.id; 

        const courseId = `course-${uuidv4()}`; // Gera um ID √∫nico para o curso

        const transaction = sanityClient.transaction(); // Inicia uma transa√ß√£o Sanity

        const lessonRefs = [];
        for (const lesson of generatedCourseData.lessons) {
            // Garante que o slug da li√ß√£o √© v√°lido, usando o slug do curso se o da li√ß√£o for nulo
            const lessonSlug = { current: lesson.slug || `${generatedCourseData.slug}-${lesson.order}` };
            const lessonId = `lesson-${uuidv4()}`; // Gera ID √∫nico para a li√ß√£o

            const newLesson = {
                _id: lessonId,
                _type: 'lesson',
                title: lesson.title,
                slug: lessonSlug,
                content: convertToPortableText(lesson.content), // Converte o texto para Portable Text
                order: lesson.order,
                estimatedReadingTime: lesson.estimatedReadingTime || 5,
                status: 'published', // Status padr√£o para novas li√ß√µes
                course: { // Refer√™ncia √† qual curso esta li√ß√£o pertence
                    _ref: courseId,
                    _type: 'reference',
                    _weak: true, // Refer√™ncia fraca, a li√ß√£o pode existir sem o curso se ele for deletado
                },
            };

            transaction.create(newLesson); // Adiciona a cria√ß√£o da li√ß√£o √† transa√ß√£o
            lessonRefs.push({ // Armazena a refer√™ncia da li√ß√£o para o campo 'lessons' do curso
                _key: uuidv4(),
                _ref: lessonId,
                _type: 'reference'
            });
            console.log(`Li√ß√£o "${lesson.title}" adicionada √† transa√ß√£o.`);
        }

        const newCourse = {
            _id: courseId,
            _type: 'course',
            title: generatedCourseData.title,
            description: generatedCourseData.description,
            slug: { current: generatedCourseData.slug },
            lessons: lessonRefs, // Links para as li√ß√µes criadas
            status: 'published',
            price: 0,
            isProContent: false,
            level: 'beginner',
            estimatedDuration: `${generatedCourseData.lessons.length * 10} minutos`,
            creator: { // Refer√™ncia ao membro que gerou este curso
                _ref: creatorId, 
                _type: 'reference',
                _weak: true,
            },
            // category e subCategory: Voc√™ pode adicionar l√≥gica para definir estes campos
            // com base no t√≥pico ou em valores padr√£o, se forem obrigat√≥rios no seu schema 'course'.
            // Ex: category: { _ref: 'someCategoryId', _type: 'reference' },
            aiGenerationPrompt: prompt, // Salva o prompt usado para auditoria
            aiModelUsed: model.model,   // Salva o modelo da IA usado
            generatedAt: new Date().toISOString(), // Data de cria√ß√£o
            lastGenerationRevision: new Date().toISOString(), // Data da √∫ltima revis√£o
        };

        transaction.create(newCourse); // Adiciona a cria√ß√£o do curso √† transa√ß√£o
        console.log(`Curso "${newCourse.title}" adicionado √† transa√ß√£o.`);

        const sanityResult = await transaction.commit(); // Executa a transa√ß√£o no Sanity
        // --- LINHA AJUSTADA ---
        console.log(`Transa√ß√£o conclu√≠da. Documentos criados: ${sanityResult.results.map(doc => doc._id).join(', ')}`);

        // Resposta de sucesso para o frontend
        res.status(201).json({
            message: 'Curso e li√ß√µes gerados e salvos com sucesso!',
            // --- LINHA AJUSTADA ---
            course: sanityResult.results[0], // Retorna o primeiro documento criado (geralmente o curso)
            lessons: generatedCourseData.lessons // Retorna os dados das li√ß√µes (n√£o os docs do Sanity)
        });

    } catch (error) {
        console.error("Erro no processo de gera√ß√£o/salvamento do curso:", error);
        // Tratamento de erros detalhado
        if (error.response && error.response.data && error.response.data.error) {
            console.error("Erro da Gemini API:", error.response.data.error);
            return res.status(500).json({ error: `Erro da Gemini API: ${error.response.data.error.message}`, details: error.response.data });
        }
        if (error.statusCode) { // Erros espec√≠ficos do Sanity Client
            console.error("Erro do Sanity:", error.message);
            return res.status(500).json({ error: `Erro do Sanity CMS: ${error.message}`, details: error });
        }
        // Catch-all para outros erros n√£o esperados
        res.status(500).json({ error: 'Falha interna ao gerar ou salvar o curso.', details: error.message });
    }
});

// --- Inicia o Servidor ---
app.listen(PORT, () => {
    console.log(`üöÄ Servidor do backend rodando em http://localhost:${PORT}`);
    console.log('Aguardando requisi√ß√µes do frontend...');
    console.log('Endpoints dispon√≠veis:');
    console.log(`GET /`);
    console.log(`POST /api/auth/register`); // Para registro de novos usu√°rios
    console.log(`POST /api/auth/login`);      // Para login de usu√°rios existentes
    console.log(`POST /api/courses/generate (protegida)`); // Requer autentica√ß√£o JWT
});